{"version":3,"file":"index.umd.production.min.js","sources":["../node_modules/dequal/lite/index.mjs","../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isObject.ts","../src/utils/isFileList.ts","../src/utils/cloneObject.ts","../src/utils/deepMerge.ts","../src/utils/isPlainObject.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/get.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isFunction.ts","../src/utils/isMultipleSelect.ts","../src/utils/isRadioInput.ts","../src/utils/runWithLowPriority.ts","../src/utils/set.ts","../src/utils/setTrueValues.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/utils/getIsDirty.ts","../src/hooks/useIsoLayoutEffect.ts","../src/useForm.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { MutableRefObject, useRef, useEffect } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n\n  useEffect(() => {\n    ref.current = val;\n  });\n\n  return ref;\n};\n","import { Map } from \"../types\";\n\nexport default (array: any[]): Map =>\n  array.reduce((obj, key) => {\n    obj[key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","import isObject from \"./isObject\";\nimport isFileList from \"./isFileList\";\n\nconst cloneObject = (object: unknown): any => {\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  if (isObject(object))\n    return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n      obj[key] = cloneObject((object as Record<string, any>)[key]);\n      return obj;\n    }, {});\n\n  throw new Error(\"Unable to clone object.\");\n};\n\nexport default cloneObject;\n","import isObject from \"./isObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isObject(prevValue) && isObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && isObject(value);\n","export default (value: unknown): value is undefined => value === undefined;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error) || error instanceof Date)\n    return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: Record<string, any>, key) => {\n    const nextErrors = filterErrors(\n      (error as Record<string, any>)[key],\n      (touched as Record<string, any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = path\n    .split(/[,[\\].]+?/)\n    .filter(Boolean)\n    .reduce((obj, key) => (obj || {})[key], object);\n\n  return isUndefined(value) ? defaultValue : value;\n};\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is Record<string, never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((callback) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          callback({\n            didTimeout: false,\n            timeRemaining: () => Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n","import cloneObject from \"./cloneObject\";\nimport isObject from \"./isObject\";\nimport isPlainObject from \"./isPlainObject\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable = false\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const segs = String(path)\n    .split(/[.[\\]]+/)\n    .filter(Boolean);\n  const newObject = immutable ? cloneObject(object) : object;\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    if (isObject(obj[key])) return obj[key];\n    const next = Number(segs[idx + 1]);\n    obj[key] = Number.isInteger(next) && next >= 0 ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","import { Map } from \"../types\";\nimport set from \"./set\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, names: string[]): Map =>\n  names.reduce((obj, name) => {\n    obj = set(obj, name, true, true);\n    return obj;\n  }, object);\n","import cloneObject from \"./cloneObject\";\nimport get from \"./get\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, immutable = false): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  let newObject = refObject;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  if (!isUndefined(get(newObject, path))) {\n    const segs = path.split(\".\");\n    let last = segs.pop() as string;\n\n    while (segs.length && segs[segs.length - 1].slice(-1) === \"\\\\\")\n      last = `${(segs.pop() as string).slice(0, -1)}.${last}`;\n\n    while (segs.length) newObject = newObject[(path = segs.shift() as string)];\n\n    delete newObject[last];\n  }\n\n  return refObject;\n};\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  Debug,\n  FormState,\n  FormStateReturn,\n  Map,\n  SetStateRef,\n  SetUsedStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: Debug<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const usedStateRef = useRef<Map>({});\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldUpdate = true } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n\n        return;\n      }\n\n      if (key === \"values\" || !dequal(get(stateRef.current, path), value)) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirtyFields,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n        } = state;\n        let { submitCount: prevSubmitCount } = state;\n        const isDirty =\n          key === \"dirtyFields\" ? getIsDirty(dirtyFields) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (prevSubmitCount += 1)\n            : prevSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n\n        path = fieldPath || path;\n\n        if (\n          shouldUpdate &&\n          (Object.keys(usedStateRef.current).some(\n            (key) => path.startsWith(key) || key.startsWith(path)\n          ) ||\n            (usedStateRef.current.isDirty && isDirty !== prevIsDirty) ||\n            (usedStateRef.current.isValid && isValid !== prevIsValid))\n        ) {\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n      }\n    },\n    [onChangeRef]\n  );\n\n  const setUsedStateRef = useCallback<SetUsedStateRef>((path) => {\n    usedStateRef.current[path] = true;\n  }, []);\n\n  return { stateRef, setStateRef, setUsedStateRef };\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst getIsDirty = (object: object): boolean => {\n  const search = (object: object, found: any[] = []) => {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const obj of Object.values(object)) {\n      if (obj === true) {\n        found.push(obj);\n        return found;\n      }\n\n      if (isPlainObject(obj)) search(obj, found);\n    }\n\n    return found;\n  };\n\n  return !!search(object).length;\n};\n\nexport default getIsDirty;\n","import { useEffect, useLayoutEffect } from \"react\";\n\nconst useIsoLayoutEffect =\n  typeof window === \"undefined\" ? useEffect : useLayoutEffect;\n\nexport default useIsoLayoutEffect;\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport {\n  Config,\n  Controller,\n  Errors,\n  FieldArgs,\n  FieldElement,\n  FieldRef,\n  Fields,\n  FieldValidator,\n  FormState,\n  FormValues,\n  GetState,\n  Map,\n  Reset,\n  Return,\n  SetErrors,\n  SetFieldError,\n  SetFieldValue,\n  SetValues,\n  Submit,\n  ValidateField,\n  ValidateForm,\n} from \"./types\";\nimport { useIsoLayoutEffect, useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  deepMerge,\n  filterErrors,\n  get,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isMultipleSelect,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isUndefined,\n  runWithLowPriority,\n  set,\n  setTrueValues,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  removeUnmountedField = true,\n  ignoreFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  debug,\n}: Config<V>): Return<V> => {\n  const isInitRef = useRef(true);\n  const formRef = useRef<HTMLFormElement>(null);\n  const fieldsRef = useRef<Fields>({});\n  const fieldArgsRef = useRef<FieldArgs>({});\n  const controllersRef = useRef<Map>({});\n  const ignoreFieldsRef = useRef<Map>(arrayToMap(ignoreFields));\n  const changedFieldRef = useRef<string>();\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<Record<string, FieldValidator<V>>>({});\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const defaultValuesRef = useRef(defaultValues);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValuesRef.current,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirtyFields: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, setUsedStateRef } = useState<V>(\n    initialStateRef.current,\n    debug\n  );\n\n  const getFields = useCallback(\n    (form: HTMLFormElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const { type, name, dataset } = field;\n\n          if (/image|submit|reset/.test(type)) return false;\n          if (!name) {\n            warn('💡 react-cool-form > field: Missing the \"name\" attribute.');\n            return false;\n          }\n\n          return (\n            controllersRef.current[name] ||\n            !(dataset.rcfIgnore || ignoreFieldsRef.current[name])\n          );\n        })\n        .reduce((acc: Record<string, any>, cur) => {\n          const field = cur as FieldElement;\n          const { name } = field;\n\n          acc[name] = { ...acc[name], field: cur };\n\n          if (isCheckboxInput(field) || isRadioInput(field))\n            acc[name].options = acc[name].options\n              ? [...acc[name].options, cur]\n              : [cur];\n\n          return acc;\n        }, {}),\n    []\n  );\n\n  const getFieldNames = useCallback(\n    () => Object.keys({ ...fieldsRef.current, ...controllersRef.current }),\n    []\n  );\n\n  const handleUnset = useCallback(\n    (path: string, fieldPath: string, target: any, name: string) => {\n      setStateRef(path, unset(target, name, true), { fieldPath });\n    },\n    [setStateRef]\n  );\n\n  const fieldRef = useCallback<FieldRef<V>>(\n    (validateOrOptions) => (field) => {\n      if (\n        !field?.name ||\n        controllersRef.current[field.name] ||\n        ignoreFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(validateOrOptions)) {\n        fieldValidatorsRef.current[field.name] = validateOrOptions;\n        return;\n      }\n\n      const { validate, ...parsers } = validateOrOptions;\n\n      if (validate) fieldValidatorsRef.current[field.name] = validate;\n      fieldArgsRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  const getNodeValue = useCallback(\n    (name: string) => {\n      const { field, options } = fieldsRef.current[name];\n      let value = field.value as any;\n\n      if (isInputElement(field)) {\n        if (fieldArgsRef.current[name]?.valueAsNumber) {\n          value = field.valueAsNumber;\n          return value;\n        }\n        if (fieldArgsRef.current[name]?.valueAsDate) {\n          value = field.valueAsDate;\n          return value;\n        }\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        value = field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        if (options) {\n          const checkboxs = options as HTMLInputElement[];\n\n          if (options.length > 1) {\n            value = checkboxs\n              .filter((checkbox) => checkbox.checked)\n              .map((checkbox) => checkbox.value);\n          } else {\n            value = checkboxs[0].checked;\n          }\n        } else {\n          let checkValues = get(stateRef.current.values, field.name);\n\n          if (Array.isArray(checkValues)) {\n            checkValues = new Set(checkValues);\n\n            if (field.checked) {\n              checkValues.add(value);\n            } else {\n              checkValues.delete(value);\n            }\n\n            value = Array.from(checkValues);\n          } else {\n            value = field.checked;\n          }\n        }\n      }\n\n      if (isRadioInput(field) && options)\n        value =\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\";\n\n      if (isMultipleSelect(field) && !options)\n        value = Array.from(field.options)\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) value = field.files;\n\n      return value;\n    },\n    [stateRef]\n  );\n\n  const setNodeValue = useCallback((name: string, value: any) => {\n    if (!fieldsRef.current[name] || controllersRef.current[name]) return;\n\n    const { field, options } = fieldsRef.current[name];\n\n    if (isCheckboxInput(field)) {\n      const checkboxs = options as HTMLInputElement[];\n\n      if (checkboxs.length > 1) {\n        checkboxs.forEach((checkbox) => {\n          checkbox.checked = Array.isArray(value)\n            ? value.includes(checkbox.value)\n            : !!value;\n        });\n      } else {\n        checkboxs[0].checked = !!value;\n      }\n    } else if (isRadioInput(field)) {\n      (options as HTMLInputElement[]).forEach((radio) => {\n        radio.checked = radio.value === value;\n      });\n    } else if (isMultipleSelect(field) && Array.isArray(value)) {\n      Array.from(field.options).forEach((option) => {\n        option.selected = !!value.includes(option.value);\n      });\n    } else if (isFileInput(field)) {\n      if (isFileList(value)) field.files = value;\n      if (!value) field.value = \"\";\n    } else {\n      field.value = value ?? \"\";\n    }\n  }, []);\n\n  const setDefaultValue = useCallback(\n    (name: string, value: any) => {\n      if (!isUndefined(get(initialStateRef.current.values, name))) return;\n\n      initialStateRef.current.values = set(\n        initialStateRef.current.values,\n        name,\n        value,\n        true\n      );\n\n      setStateRef(`values.${name}`, get(initialStateRef.current.values, name), {\n        shouldUpdate: !isInitRef.current,\n      });\n    },\n    [setStateRef]\n  );\n\n  const setAllNodesOrStateValue = useCallback(\n    (values: V, checkDefaultValues = false) =>\n      Object.values(fieldsRef.current).forEach(({ field: { name } }) => {\n        if (controllersRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (checkDefaultValues) {\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          setDefaultValue(\n            name,\n            !isUndefined(defaultValue) ? defaultValue : getNodeValue(name)\n          );\n        }\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const getState = useCallback<GetState>(\n    (path, { target, watch = true, filterUntouchedError = true } = {}) => {\n      const getPath = (path: string) => {\n        if (path === \"values\" && !target && watch)\n          warn(\n            '💡 react-cool-form > getState: Get the \"values\" alone may cause unnecessary re-renders. If you know what you\\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/form-state'\n          );\n\n        return target ? `${target}.${path}` : path;\n      };\n      const errorsEnhancer = (path: string, state: any) => {\n        if (\n          !watch ||\n          !filterUntouchedError ||\n          !path.startsWith(\"errors\") ||\n          !state ||\n          isEmptyObject(state)\n        )\n          return state;\n\n        path = path.replace(\"errors\", \"touched\");\n        setUsedStateRef(path);\n\n        return filterErrors(state, get(stateRef.current, path));\n      };\n      let state;\n\n      if (Array.isArray(path)) {\n        state = path.map((path) => {\n          path = getPath(path);\n          if (watch) setUsedStateRef(path);\n          return errorsEnhancer(path, get(stateRef.current, path));\n        });\n      } else if (isPlainObject(path)) {\n        const paths = path as Record<string, string>;\n        state = Object.keys(paths).reduce((state: Record<string, any>, key) => {\n          path = getPath(paths[key]);\n          if (watch) setUsedStateRef(path);\n          state[key] = errorsEnhancer(path, get(stateRef.current, path));\n          return state;\n        }, {});\n      } else {\n        path = getPath(path);\n        if (watch) setUsedStateRef(path);\n        state = errorsEnhancer(path, get(stateRef.current, path));\n      }\n\n      return state;\n    },\n    [setUsedStateRef, stateRef]\n  );\n\n  const setErrors = useCallback<SetErrors<V>>(\n    (errors) => {\n      setStateRef(\n        \"errors\",\n        (isFunction(errors) ? errors(stateRef.current.errors) : errors) || {}\n      );\n    },\n    [setStateRef, stateRef]\n  );\n\n  const setFieldError = useCallback<SetFieldError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => fieldsRef.current[name]?.field.validationMessage,\n    []\n  );\n\n  const runAllBuiltInValidation = useCallback(\n    () =>\n      Object.keys(fieldsRef.current).reduce((errors, name) => {\n        const error = runBuiltInValidation(name);\n        errors = { ...errors, ...(error ? set({}, name, error) : {}) };\n        return errors;\n      }, {}),\n    [runBuiltInValidation]\n  );\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      if (!fieldValidatorsRef.current[name]) return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          get(stateRef.current.values, name),\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`💡 react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<Errors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set({}, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`💡 react-cool-form > config.validate: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback<ValidateField>(\n    async (name) => {\n      setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setFieldError(name, error);\n        setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setFieldError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<ValidateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback<ValidateForm<V>>(() => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setErrors(errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setErrors,\n    setStateRef,\n  ]);\n\n  const validateFormWithLowPriority = useCallback<ValidateForm<V>>(\n    () => runWithLowPriority(validateForm),\n    [validateForm]\n  );\n\n  const setFieldDirty = useCallback(\n    (name: string) => {\n      if (\n        get(stateRef.current.values, name) !==\n        get(initialStateRef.current.values, name)\n      ) {\n        setStateRef(`dirtyFields.${name}`, true);\n      } else {\n        handleUnset(\n          \"dirtyFields\",\n          `dirtyFields.${name}`,\n          stateRef.current.dirtyFields,\n          name\n        );\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const setFieldTouched = useCallback(\n    (name: string, shouldValidate = validateOnBlur) => {\n      setStateRef(`touched.${name}`, true);\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [setStateRef, validateFieldWithLowPriority, validateOnBlur]\n  );\n\n  const setFieldTouchedMaybeValidate = useCallback(\n    (name) =>\n      setFieldTouched(\n        name,\n        validateOnChange ? name !== changedFieldRef.current : undefined\n      ),\n    [setFieldTouched, validateOnChange]\n  );\n\n  const setValues = useCallback<SetValues<V>>(\n    (\n      values,\n      {\n        shouldValidate = validateOnChange,\n        touchedFields = [],\n        dirtyFields = [],\n      } = {}\n    ) => {\n      values = isFunction(values) ? values(stateRef.current.values) : values;\n\n      setStateRef(\"values\", values);\n      setAllNodesOrStateValue(values);\n\n      if (touchedFields.length)\n        setStateRef(\n          \"touched\",\n          setTrueValues(\n            stateRef.current.touched,\n            isFunction(touchedFields)\n              ? touchedFields(getFieldNames())\n              : touchedFields\n          )\n        );\n      if (dirtyFields.length)\n        setStateRef(\n          \"dirtyFields\",\n          setTrueValues(\n            stateRef.current.dirtyFields,\n            isFunction(dirtyFields) ? dirtyFields(getFieldNames()) : dirtyFields\n          )\n        );\n      if (shouldValidate) validateFormWithLowPriority();\n    },\n    [\n      getFieldNames,\n      setAllNodesOrStateValue,\n      setStateRef,\n      stateRef,\n      validateFormWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const setFieldValue = useCallback<SetFieldValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(\"values\", `values.${name}`, stateRef.current.values, name);\n      }\n      setNodeValue(name, value);\n\n      if (shouldTouched) setFieldTouched(name, false);\n      if (shouldDirty) setFieldDirty(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setFieldDirty,\n      setFieldTouched,\n      setNodeValue,\n      setStateRef,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      formState: stateRef.current,\n      setErrors,\n      setFieldError,\n      setValues,\n      setFieldValue,\n      validateForm,\n      validateField,\n      reset,\n      submit,\n    }),\n    [\n      // @ts-expect-error\n      reset,\n      setErrors,\n      setFieldError,\n      setFieldValue,\n      setValues,\n      stateRef,\n      // @ts-expect-error\n      submit,\n      validateField,\n      validateForm,\n    ]\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          values =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = values;\n          setAllNodesOrStateValue(values);\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n    },\n    [getOptions, onResetRef, setAllNodesOrStateValue, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const { touched, values } = stateRef.current;\n\n      setStateRef(\"touched\", setTrueValues(touched, getFieldNames()));\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const errors = await validateForm();\n\n        if (!isEmptyObject(errors)) {\n          onErrorRef.current(errors, getOptions(), e);\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values };\n      } catch (exception) {\n        warn(`💡 react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [\n      getFieldNames,\n      getOptions,\n      onErrorRef,\n      onSubmitRef,\n      setStateRef,\n      stateRef,\n      validateForm,\n    ]\n  );\n\n  const handleChangeEvent = useCallback(\n    (name: string, value: any) => {\n      setStateRef(`values.${name}`, value);\n      setFieldDirty(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [setFieldDirty, setStateRef, validateFieldWithLowPriority, validateOnChange]\n  );\n\n  const controller = useCallback<Controller<V>>(\n    (\n      name,\n      { validate, value, defaultValue, parse, format, onChange, onBlur } = {}\n    ) => {\n      if (!name) {\n        warn('💡 react-cool-form > controller: Missing the \"name\" parameter.');\n        return undefined;\n      }\n\n      controllersRef.current[name] = true;\n      if (validate) fieldValidatorsRef.current[name] = validate;\n\n      const val = get(defaultValuesRef.current, name);\n      defaultValue = !isUndefined(val) ? val : defaultValue;\n      if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);\n\n      value = !isUndefined(value) ? value : getState(`values.${name}`);\n      value = (format ? format(value) : value) ?? \"\";\n\n      return {\n        name,\n        value,\n        onChange: (e) => {\n          const value =\n            e.nativeEvent instanceof Event && isFieldElement(e.target)\n              ? getNodeValue(name)\n              : e;\n\n          handleChangeEvent(name, parse ? parse(value) : value);\n          if (onChange) onChange(e, value);\n          changedFieldRef.current = name;\n        },\n        onBlur: (e) => {\n          setFieldTouchedMaybeValidate(name);\n          if (onBlur) onBlur(e);\n          changedFieldRef.current = undefined;\n        },\n      };\n    },\n    [\n      getNodeValue,\n      getState,\n      handleChangeEvent,\n      setDefaultValue,\n      setFieldTouchedMaybeValidate,\n    ]\n  );\n\n  useIsoLayoutEffect(() => {\n    if (!formRef.current) return;\n\n    fieldsRef.current = getFields(formRef.current);\n    setAllNodesOrStateValue(initialStateRef.current.values, true);\n    isInitRef.current = false;\n  }, [getFields, setAllNodesOrStateValue]);\n\n  useEffect(() => {\n    if (!formRef.current) return () => null;\n\n    const handleChange = ({ target }: Event) => {\n      const { name } = target as FieldElement;\n\n      if (!name) {\n        warn('💡 react-cool-form > field: Missing the \"name\" attribute.');\n        return;\n      }\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        const parse = fieldArgsRef.current[name]?.parse;\n        const value = getNodeValue(name);\n\n        handleChangeEvent(name, parse ? parse(value) : value);\n        changedFieldRef.current = name;\n      }\n    };\n\n    const handleBlur = ({ target }: Event) => {\n      if (!isFieldElement(target as HTMLElement)) return;\n\n      const { name } = target as FieldElement;\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        setFieldTouchedMaybeValidate(name);\n        changedFieldRef.current = undefined;\n      }\n    };\n\n    const handleSubmit = (e: Event) => submit(e as any);\n\n    const handleReset = (e: Event) => reset(null, null, e as any);\n\n    const form = formRef.current;\n    form.addEventListener(\"input\", handleChange);\n    form.addEventListener(\"focusout\", handleBlur);\n    form.addEventListener(\"submit\", handleSubmit);\n    form.addEventListener(\"reset\", handleReset);\n\n    const observer = new MutationObserver(([{ type }]) => {\n      if (type !== \"childList\") return;\n\n      const fields = getFields(form);\n      let { values } = stateRef.current;\n\n      if (removeUnmountedField)\n        Object.keys(fieldsRef.current).forEach((name) => {\n          if (fields[name]) return;\n\n          handleUnset(\n            \"values\",\n            `values.${name}`,\n            stateRef.current.values,\n            name\n          );\n          handleUnset(\n            \"touched\",\n            `touched.${name}`,\n            stateRef.current.touched,\n            name\n          );\n          handleUnset(\n            \"dirtyFields\",\n            `dirtyFields.${name}`,\n            stateRef.current.dirtyFields,\n            name\n          );\n          handleUnset(\n            \"errors\",\n            `errors.${name}`,\n            stateRef.current.errors,\n            name\n          );\n\n          initialStateRef.current.values = unset(\n            initialStateRef.current.values,\n            name,\n            true\n          );\n\n          delete fieldArgsRef.current[name];\n          delete fieldValidatorsRef.current[name];\n          delete controllersRef.current[name];\n        });\n\n      let isAdd = false;\n\n      Object.keys(fields).forEach((name) => {\n        if (fieldsRef.current[name] || controllersRef.current[name]) return;\n\n        const defaultValue = get(defaultValuesRef.current, name);\n\n        if (!isUndefined(defaultValue))\n          values = set(values, name, defaultValue, true);\n\n        isAdd = true;\n      });\n\n      fieldsRef.current = fields;\n      if (isAdd) setAllNodesOrStateValue(values, true);\n    });\n    observer.observe(form, { childList: true, subtree: true });\n\n    return () => {\n      form.removeEventListener(\"input\", handleChange);\n      form.removeEventListener(\"focusout\", handleBlur);\n      form.removeEventListener(\"submit\", handleSubmit);\n      form.removeEventListener(\"reset\", handleReset);\n      observer.disconnect();\n    };\n  }, [\n    getFields,\n    getNodeValue,\n    handleChangeEvent,\n    handleUnset,\n    removeUnmountedField,\n    reset,\n    setAllNodesOrStateValue,\n    setFieldTouchedMaybeValidate,\n    stateRef,\n    submit,\n  ]);\n\n  return {\n    form: formRef,\n    field: fieldRef,\n    getState,\n    setErrors,\n    setFieldError,\n    setValues,\n    setFieldValue,\n    validateForm,\n    validateField,\n    reset,\n    submit,\n    controller,\n  };\n};\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n"],"names":["has","Object","prototype","hasOwnProperty","dequal","foo","bar","ctor","len","constructor","Date","getTime","RegExp","toString","Array","length","call","keys","val","ref","useRef","useEffect","current","array","reduce","obj","key","value","FileList","cloneObject","object","isObject","isFileList","isArray","map","Error","deepMerge","objects","prev","forEach","prevValue","currValue","undefined","filterErrors","error","touched","isPlainObject","nextErrors","isUndefined","path","defaultValue","split","filter","Boolean","field","type","element","test","tagName","callback","window","requestIdleCallback","start","now","setTimeout","didTimeout","timeRemaining","Math","max","timeout","immutable","TypeError","segs","String","newObject","slice","idx","next","Number","isInteger","names","name","set","refObject","get","last","pop","shift","initialState","onChange","forceUpdate","useReducer","c","stateRef","usedStateRef","onChangeRef","useLatest","setStateRef","useCallback","fieldPath","shouldUpdate","state","errors","dirtyFields","prevIsDirty","isDirty","prevIsValid","isValid","prevSubmitCount","submitCount","search","found","values","push","isEmptyObject","some","startsWith","setUsedStateRef","useIsoLayoutEffect","useLayoutEffect","defaultValues","validate","validateOnChange","validateOnBlur","removeUnmountedField","ignoreFields","onReset","onSubmit","onError","debug","isInitRef","formRef","fieldsRef","fieldArgsRef","controllersRef","ignoreFieldsRef","arrayToMap","changedFieldRef","formValidatorRef","fieldValidatorsRef","onResetRef","onSubmitRef","onErrorRef","defaultValuesRef","initialStateRef","isValidating","isSubmitting","isSubmitted","useState","getFields","form","from","querySelectorAll","dataset","rcfIgnore","acc","cur","isCheckboxInput","isRadioInput","options","getFieldNames","handleUnset","target","unset","fieldRef","validateOrOptions","isFunction","parsers","getNodeValue","_fieldArgsRef$current","valueAsNumber","_fieldArgsRef$current2","valueAsDate","isNumberInput","isRangeInput","checkboxs","checkbox","checked","checkValues","Set","add","find","radio","isMultipleSelect","option","selected","isFileInput","files","setNodeValue","includes","setDefaultValue","setAllNodesOrStateValue","checkDefaultValues","getState","watch","filterUntouchedError","getPath","errorsEnhancer","replace","paths","setErrors","setFieldError","runBuiltInValidation","_fieldsRef$current$na3","validationMessage","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","all","then","runFormValidation","validateField","validateFieldWithLowPriority","runWithLowPriority","validateForm","errs","validateFormWithLowPriority","setFieldDirty","setFieldTouched","shouldValidate","setFieldTouchedMaybeValidate","setValues","touchedFields","setTrueValues","setFieldValue","shouldTouched","shouldDirty","getOptions","formState","reset","submit","exclude","e","preventDefault","stopPropagation","skip","handleChangeEvent","controller","parse","format","onBlur","nativeEvent","Event","isFieldElement","handleChange","_fieldArgsRef$current3","handleBlur","handleSubmit","handleReset","addEventListener","observer","MutationObserver","fields","isAdd","observe","childList","subtree","removeEventListener","disconnect"],"mappings":"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"}