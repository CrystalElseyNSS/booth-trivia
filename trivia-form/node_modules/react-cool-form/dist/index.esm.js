import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';
import _extends from '@babel/runtime/helpers/extends';
import { useRef, useEffect, useReducer, useCallback, useLayoutEffect } from 'react';
import { dequal } from 'dequal/lite';

var useLatest = (function (val) {
  var ref = useRef(val);
  useEffect(function () {
    ref.current = val;
  });
  return ref;
});

var arrayToMap = (function (array) {
  return array.reduce(function (obj, key) {
    obj[key] = true;
    return obj;
  }, {});
});

var isObject = (function (value) {
  return value !== null && typeof value === "object";
});

var isFileList = (function (value) {
  return value instanceof FileList;
});

var cloneObject = function cloneObject(object) {
  if (!isObject(object) || isFileList(object)) return object;
  if (object instanceof Date) return new Date(object.getTime());
  if (Array.isArray(object)) return object.map(function (val) {
    return cloneObject(val);
  });
  if (isObject(object)) return Object.keys(object).reduce(function (obj, key) {
    obj[key] = cloneObject(object[key]);
    return obj;
  }, {});
  throw new Error("Unable to clone object.");
};

var deepMerge = function deepMerge() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }

  return objects.reduce(function (prev, obj) {
    Object.keys(obj).forEach(function (key) {
      var prevValue = prev[key];
      var currValue = obj[key];

      if (Array.isArray(prevValue) && Array.isArray(currValue)) {
        prev[key] = [].concat(prevValue, currValue);
      } else if (isObject(prevValue) && isObject(currValue)) {
        prev[key] = deepMerge(prevValue, currValue);
      } else {
        prev[key] = currValue;
      }
    });
    return prev;
  }, {});
};

var isPlainObject = (function (value) {
  return !Array.isArray(value) && isObject(value);
});

var isUndefined = (function (value) {
  return value === undefined;
});

var filterErrors = function filterErrors(error, touched) {
  if (!isPlainObject(error) || error instanceof Date) return touched ? error : undefined;
  return Object.keys(error).reduce(function (obj, key) {
    var nextErrors = filterErrors(error[key], touched[key] || false);

    if (!isUndefined(nextErrors)) {
      obj[key] = nextErrors;
    } else {
      delete obj[key];
    }

    return obj;
  }, {});
};

var get = (function (object, path, defaultValue) {
  if (!isPlainObject(object) || !path) return defaultValue;
  var value = path.split(/[,[\].]+?/).filter(Boolean).reduce(function (obj, key) {
    return (obj || {})[key];
  }, object);
  return isUndefined(value) ? defaultValue : value;
});

var getIsDirty = function getIsDirty(object) {
  var search = function search(object, found) {
    if (found === void 0) {
      found = [];
    }

    // eslint-disable-next-line no-restricted-syntax
    for (var _i = 0, _Object$values = Object.values(object); _i < _Object$values.length; _i++) {
      var obj = _Object$values[_i];

      if (obj === true) {
        found.push(obj);
        return found;
      }

      if (isPlainObject(obj)) search(obj, found);
    }

    return found;
  };

  return !!search(object).length;
};

var isCheckboxInput = (function (field) {
  return field.type === "checkbox";
});

var isEmptyObject = (function (value) {
  return isPlainObject(value) && !Object.keys(value).length;
});

var isFieldElement = (function (element) {
  return /INPUT|TEXTAREA|SELECT/.test(element.tagName);
});

var isFileInput = (function (field) {
  return field.type === "file";
});

var isFunction = (function (value) {
  return typeof value === "function";
});

var isInputElement = (function (element) {
  return element.tagName === "INPUT";
});

var isMultipleSelect = (function (field) {
  return field.type === "select-multiple";
});

var isNumberInput = (function (field) {
  return field.type === "number";
});

var isRadioInput = (function (field) {
  return field.type === "radio";
});

var isRangeInput = (function (field) {
  return field.type === "range";
});

var runWithLowPriority = (function (callback) {
  return (window.requestIdleCallback || function (callback) {
    var start = Date.now();
    return setTimeout(function () {
      return callback({
        didTimeout: false,
        timeRemaining: function timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        }
      });
    }, 1);
  })(callback, {
    timeout: 2000
  });
});

var set = (function (object, path, value, immutable) {
  if (immutable === void 0) {
    immutable = false;
  }

  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var segs = String(path).split(/[.[\]]+/).filter(Boolean);
  var newObject = immutable ? cloneObject(object) : object;
  segs.slice(0, -1).reduce(function (obj, key, idx) {
    if (isObject(obj[key])) return obj[key];
    var next = Number(segs[idx + 1]);
    obj[key] = Number.isInteger(next) && next >= 0 ? [] : {};
    return obj[key];
  }, newObject)[segs[segs.length - 1] || ""] = value;
  return newObject;
});

var setTrueValues = (function (object, names) {
  return names.reduce(function (obj, name) {
    obj = set(obj, name, true, true);
    return obj;
  }, object);
});

var unset = (function (object, path, immutable) {
  if (immutable === void 0) {
    immutable = false;
  }

  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var refObject = immutable ? cloneObject(object) : object;
  var newObject = refObject; // eslint-disable-next-line no-prototype-builtins

  if (newObject.hasOwnProperty(path)) {
    delete newObject[path];
    return refObject;
  }

  if (!isUndefined(get(newObject, path))) {
    var segs = path.split(".");
    var last = segs.pop();

    while (segs.length && segs[segs.length - 1].slice(-1) === "\\") {
      last = segs.pop().slice(0, -1) + "." + last;
    }

    while (segs.length) {
      newObject = newObject[path = segs.shift()];
    }

    delete newObject[last];
  }

  return refObject;
});

var warn = (function () {
  var _console;

  if (process.env.NODE_ENV !== "production") (_console = console).warn.apply(_console, arguments);
});

var useState = (function (initialState, onChange) {
  var _useReducer = useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _useReducer[1];

  var stateRef = useRef(initialState);
  var usedStateRef = useRef({});
  var onChangeRef = useLatest(onChange || function () {
    return undefined;
  });
  var setStateRef = useCallback(function (path, value, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        fieldPath = _ref.fieldPath,
        _ref$shouldUpdate = _ref.shouldUpdate,
        shouldUpdate = _ref$shouldUpdate === void 0 ? true : _ref$shouldUpdate;

    var key = path.split(".")[0];

    if (!key) {
      if (!dequal(stateRef.current, value)) {
        stateRef.current = value;
        forceUpdate();
        onChangeRef.current(stateRef.current);
      }

      return;
    }

    if (key === "values" || !dequal(get(stateRef.current, path), value)) {
      var state = set(stateRef.current, path, value, true);
      var errors = state.errors,
          dirtyFields = state.dirtyFields,
          prevIsDirty = state.isDirty,
          prevIsValid = state.isValid;
      var prevSubmitCount = state.submitCount;
      var isDirty = key === "dirtyFields" ? getIsDirty(dirtyFields) : prevIsDirty;
      var isValid = key === "errors" ? isEmptyObject(errors) : prevIsValid;
      var submitCount = key === "isSubmitting" && value ? prevSubmitCount += 1 : prevSubmitCount;
      stateRef.current = _extends({}, state, {
        isDirty: isDirty,
        isValid: isValid,
        submitCount: submitCount
      });
      path = fieldPath || path;

      if (shouldUpdate && (Object.keys(usedStateRef.current).some(function (key) {
        return path.startsWith(key) || key.startsWith(path);
      }) || usedStateRef.current.isDirty && isDirty !== prevIsDirty || usedStateRef.current.isValid && isValid !== prevIsValid)) {
        forceUpdate();
        onChangeRef.current(stateRef.current);
      }
    }
  }, [onChangeRef]);
  var setUsedStateRef = useCallback(function (path) {
    usedStateRef.current[path] = true;
  }, []);
  return {
    stateRef: stateRef,
    setStateRef: setStateRef,
    setUsedStateRef: setUsedStateRef
  };
});

var useIsoLayoutEffect = typeof window === "undefined" ? useEffect : useLayoutEffect;

var useForm = (function (_ref) {
  var _ref$defaultValues = _ref.defaultValues,
      defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues,
      validate = _ref.validate,
      _ref$validateOnChange = _ref.validateOnChange,
      validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,
      _ref$validateOnBlur = _ref.validateOnBlur,
      validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,
      _ref$removeUnmountedF = _ref.removeUnmountedField,
      removeUnmountedField = _ref$removeUnmountedF === void 0 ? true : _ref$removeUnmountedF,
      _ref$ignoreFields = _ref.ignoreFields,
      ignoreFields = _ref$ignoreFields === void 0 ? [] : _ref$ignoreFields,
      onReset = _ref.onReset,
      onSubmit = _ref.onSubmit,
      onError = _ref.onError,
      debug = _ref.debug;
  var isInitRef = useRef(true);
  var formRef = useRef(null);
  var fieldsRef = useRef({});
  var fieldArgsRef = useRef({});
  var controllersRef = useRef({});
  var ignoreFieldsRef = useRef(arrayToMap(ignoreFields));
  var changedFieldRef = useRef();
  var formValidatorRef = useLatest(validate);
  var fieldValidatorsRef = useRef({});
  var onResetRef = useLatest(onReset || function () {
    return undefined;
  });
  var onSubmitRef = useLatest(onSubmit || function () {
    return undefined;
  });
  var onErrorRef = useLatest(onError || function () {
    return undefined;
  });
  var defaultValuesRef = useRef(defaultValues);
  var initialStateRef = useRef({
    values: defaultValuesRef.current,
    touched: {},
    errors: {},
    isDirty: false,
    dirtyFields: {},
    isValidating: false,
    isValid: true,
    isSubmitting: false,
    isSubmitted: false,
    submitCount: 0
  });

  var _useState = useState(initialStateRef.current, debug),
      stateRef = _useState.stateRef,
      setStateRef = _useState.setStateRef,
      setUsedStateRef = _useState.setUsedStateRef;

  var getFields = useCallback(function (form) {
    return Array.from(form.querySelectorAll("input,textarea,select")).filter(function (element) {
      var field = element;
      var type = field.type,
          name = field.name,
          dataset = field.dataset;
      if (/image|submit|reset/.test(type)) return false;

      if (!name) {
        warn('💡 react-cool-form > field: Missing the "name" attribute.');
        return false;
      }

      return controllersRef.current[name] || !(dataset.rcfIgnore || ignoreFieldsRef.current[name]);
    }).reduce(function (acc, cur) {
      var field = cur;
      var name = field.name;
      acc[name] = _extends({}, acc[name], {
        field: cur
      });
      if (isCheckboxInput(field) || isRadioInput(field)) acc[name].options = acc[name].options ? [].concat(acc[name].options, [cur]) : [cur];
      return acc;
    }, {});
  }, []);
  var getFieldNames = useCallback(function () {
    return Object.keys(_extends({}, fieldsRef.current, controllersRef.current));
  }, []);
  var handleUnset = useCallback(function (path, fieldPath, target, name) {
    setStateRef(path, unset(target, name, true), {
      fieldPath: fieldPath
    });
  }, [setStateRef]);
  var fieldRef = useCallback(function (validateOrOptions) {
    return function (field) {
      if (!(field != null && field.name) || controllersRef.current[field.name] || ignoreFieldsRef.current[field.name]) return;

      if (isFunction(validateOrOptions)) {
        fieldValidatorsRef.current[field.name] = validateOrOptions;
        return;
      }

      var validate = validateOrOptions.validate,
          parsers = _objectWithoutPropertiesLoose(validateOrOptions, ["validate"]);

      if (validate) fieldValidatorsRef.current[field.name] = validate;
      fieldArgsRef.current[field.name] = parsers;
    };
  }, []);
  var getNodeValue = useCallback(function (name) {
    var _find;

    var _fieldsRef$current$na = fieldsRef.current[name],
        field = _fieldsRef$current$na.field,
        options = _fieldsRef$current$na.options;
    var value = field.value;

    if (isInputElement(field)) {
      var _fieldArgsRef$current, _fieldArgsRef$current2;

      if ((_fieldArgsRef$current = fieldArgsRef.current[name]) != null && _fieldArgsRef$current.valueAsNumber) {
        value = field.valueAsNumber;
        return value;
      }

      if ((_fieldArgsRef$current2 = fieldArgsRef.current[name]) != null && _fieldArgsRef$current2.valueAsDate) {
        value = field.valueAsDate;
        return value;
      }
    }

    if (isNumberInput(field) || isRangeInput(field)) value = field.valueAsNumber || "";

    if (isCheckboxInput(field)) {
      if (options) {
        var checkboxs = options;

        if (options.length > 1) {
          value = checkboxs.filter(function (checkbox) {
            return checkbox.checked;
          }).map(function (checkbox) {
            return checkbox.value;
          });
        } else {
          value = checkboxs[0].checked;
        }
      } else {
        var checkValues = get(stateRef.current.values, field.name);

        if (Array.isArray(checkValues)) {
          checkValues = new Set(checkValues);

          if (field.checked) {
            checkValues.add(value);
          } else {
            checkValues["delete"](value);
          }

          value = Array.from(checkValues);
        } else {
          value = field.checked;
        }
      }
    }

    if (isRadioInput(field) && options) value = ((_find = options.find(function (radio) {
      return radio.checked;
    })) == null ? void 0 : _find.value) || "";
    if (isMultipleSelect(field) && !options) value = Array.from(field.options).filter(function (option) {
      return option.selected;
    }).map(function (option) {
      return option.value;
    });
    if (isFileInput(field)) value = field.files;
    return value;
  }, [stateRef]);
  var setNodeValue = useCallback(function (name, value) {
    if (!fieldsRef.current[name] || controllersRef.current[name]) return;
    var _fieldsRef$current$na2 = fieldsRef.current[name],
        field = _fieldsRef$current$na2.field,
        options = _fieldsRef$current$na2.options;

    if (isCheckboxInput(field)) {
      var checkboxs = options;

      if (checkboxs.length > 1) {
        checkboxs.forEach(function (checkbox) {
          checkbox.checked = Array.isArray(value) ? value.includes(checkbox.value) : !!value;
        });
      } else {
        checkboxs[0].checked = !!value;
      }
    } else if (isRadioInput(field)) {
      options.forEach(function (radio) {
        radio.checked = radio.value === value;
      });
    } else if (isMultipleSelect(field) && Array.isArray(value)) {
      Array.from(field.options).forEach(function (option) {
        option.selected = !!value.includes(option.value);
      });
    } else if (isFileInput(field)) {
      if (isFileList(value)) field.files = value;
      if (!value) field.value = "";
    } else {
      field.value = value != null ? value : "";
    }
  }, []);
  var setDefaultValue = useCallback(function (name, value) {
    if (!isUndefined(get(initialStateRef.current.values, name))) return;
    initialStateRef.current.values = set(initialStateRef.current.values, name, value, true);
    setStateRef("values." + name, get(initialStateRef.current.values, name), {
      shouldUpdate: !isInitRef.current
    });
  }, [setStateRef]);
  var setAllNodesOrStateValue = useCallback(function (values, checkDefaultValues) {
    if (checkDefaultValues === void 0) {
      checkDefaultValues = false;
    }

    return Object.values(fieldsRef.current).forEach(function (_ref2) {
      var name = _ref2.field.name;
      if (controllersRef.current[name]) return;
      var value = get(values, name);
      if (!isUndefined(value)) setNodeValue(name, value);

      if (checkDefaultValues) {
        var defaultValue = get(defaultValuesRef.current, name);
        setDefaultValue(name, !isUndefined(defaultValue) ? defaultValue : getNodeValue(name));
      }
    });
  }, [getNodeValue, setDefaultValue, setNodeValue]);
  var getState = useCallback(function (path, _temp) {
    var _ref3 = _temp === void 0 ? {} : _temp,
        target = _ref3.target,
        _ref3$watch = _ref3.watch,
        watch = _ref3$watch === void 0 ? true : _ref3$watch,
        _ref3$filterUntouched = _ref3.filterUntouchedError,
        filterUntouchedError = _ref3$filterUntouched === void 0 ? true : _ref3$filterUntouched;

    var getPath = function getPath(path) {
      if (path === "values" && !target && watch) warn('💡 react-cool-form > getState: Get the "values" alone may cause unnecessary re-renders. If you know what you\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/form-state');
      return target ? target + "." + path : path;
    };

    var errorsEnhancer = function errorsEnhancer(path, state) {
      if (!watch || !filterUntouchedError || !path.startsWith("errors") || !state || isEmptyObject(state)) return state;
      path = path.replace("errors", "touched");
      setUsedStateRef(path);
      return filterErrors(state, get(stateRef.current, path));
    };

    var state;

    if (Array.isArray(path)) {
      state = path.map(function (path) {
        path = getPath(path);
        if (watch) setUsedStateRef(path);
        return errorsEnhancer(path, get(stateRef.current, path));
      });
    } else if (isPlainObject(path)) {
      var paths = path;
      state = Object.keys(paths).reduce(function (state, key) {
        path = getPath(paths[key]);
        if (watch) setUsedStateRef(path);
        state[key] = errorsEnhancer(path, get(stateRef.current, path));
        return state;
      }, {});
    } else {
      path = getPath(path);
      if (watch) setUsedStateRef(path);
      state = errorsEnhancer(path, get(stateRef.current, path));
    }

    return state;
  }, [setUsedStateRef, stateRef]);
  var setErrors = useCallback(function (errors) {
    setStateRef("errors", (isFunction(errors) ? errors(stateRef.current.errors) : errors) || {});
  }, [setStateRef, stateRef]);
  var setFieldError = useCallback(function (name, error) {
    error = isFunction(error) ? error(get(stateRef.current.errors, name)) : error;

    if (error) {
      setStateRef("errors." + name, error);
    } else {
      handleUnset("errors", "errors." + name, stateRef.current.errors, name);
    }
  }, [handleUnset, setStateRef, stateRef]);
  var runBuiltInValidation = useCallback(function (name) {
    var _fieldsRef$current$na3;

    return (_fieldsRef$current$na3 = fieldsRef.current[name]) == null ? void 0 : _fieldsRef$current$na3.field.validationMessage;
  }, []);
  var runAllBuiltInValidation = useCallback(function () {
    return Object.keys(fieldsRef.current).reduce(function (errors, name) {
      var error = runBuiltInValidation(name);
      errors = _extends({}, errors, error ? set({}, name, error) : {});
      return errors;
    }, {});
  }, [runBuiltInValidation]);
  var runFieldValidation = useCallback(async function (name) {
    if (!fieldValidatorsRef.current[name]) return undefined;

    try {
      var error = await fieldValidatorsRef.current[name](get(stateRef.current.values, name), stateRef.current.values);
      return error;
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > validate " + name + ": ", exception);
      throw exception;
    }
  }, [stateRef]);
  var runAllFieldsValidation = useCallback(function () {
    var promises = Object.keys(fieldValidatorsRef.current).map(function (name) {
      return runFieldValidation(name);
    });
    return Promise.all(promises).then(function (errors) {
      return Object.keys(fieldValidatorsRef.current).reduce(function (acc, cur, idx) {
        acc = _extends({}, acc, errors[idx] ? set({}, cur, errors[idx]) : {});
        return acc;
      }, {});
    });
  }, [runFieldValidation]);
  var runFormValidation = useCallback(async function (name) {
    if (!formValidatorRef.current) return name ? undefined : {};

    try {
      var errors = await formValidatorRef.current(stateRef.current.values);
      if (name) return get(errors, name);
      return isPlainObject(errors) ? errors : {};
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > config.validate: ", exception);
      throw exception;
    }
  }, [formValidatorRef, stateRef]);
  var validateField = useCallback(async function (name) {
    setStateRef("isValidating", true);

    try {
      var error = (await runFormValidation(name)) || (await runFieldValidation(name)) || runBuiltInValidation(name);
      setFieldError(name, error);
      setStateRef("isValidating", false);
      return error;
    } catch (exception) {
      return exception;
    }
  }, [runBuiltInValidation, runFieldValidation, runFormValidation, setFieldError, setStateRef]);
  var validateFieldWithLowPriority = useCallback(function (name) {
    return runWithLowPriority(function () {
      return validateField(name);
    });
  }, [validateField]);
  var validateForm = useCallback(function () {
    setStateRef("isValidating", true);
    return Promise.all([runAllBuiltInValidation(), runAllFieldsValidation(), runFormValidation()]).then(function (errors) {
      var errs = deepMerge.apply(void 0, errors);
      setErrors(errs);
      setStateRef("isValidating", false);
      return errs;
    });
  }, [runAllBuiltInValidation, runAllFieldsValidation, runFormValidation, setErrors, setStateRef]);
  var validateFormWithLowPriority = useCallback(function () {
    return runWithLowPriority(validateForm);
  }, [validateForm]);
  var setFieldDirty = useCallback(function (name) {
    if (get(stateRef.current.values, name) !== get(initialStateRef.current.values, name)) {
      setStateRef("dirtyFields." + name, true);
    } else {
      handleUnset("dirtyFields", "dirtyFields." + name, stateRef.current.dirtyFields, name);
    }
  }, [handleUnset, setStateRef, stateRef]);
  var setFieldTouched = useCallback(function (name, shouldValidate) {
    if (shouldValidate === void 0) {
      shouldValidate = validateOnBlur;
    }

    setStateRef("touched." + name, true);
    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [setStateRef, validateFieldWithLowPriority, validateOnBlur]);
  var setFieldTouchedMaybeValidate = useCallback(function (name) {
    return setFieldTouched(name, validateOnChange ? name !== changedFieldRef.current : undefined);
  }, [setFieldTouched, validateOnChange]);
  var setValues = useCallback(function (values, _temp2) {
    var _ref4 = _temp2 === void 0 ? {} : _temp2,
        _ref4$shouldValidate = _ref4.shouldValidate,
        shouldValidate = _ref4$shouldValidate === void 0 ? validateOnChange : _ref4$shouldValidate,
        _ref4$touchedFields = _ref4.touchedFields,
        touchedFields = _ref4$touchedFields === void 0 ? [] : _ref4$touchedFields,
        _ref4$dirtyFields = _ref4.dirtyFields,
        dirtyFields = _ref4$dirtyFields === void 0 ? [] : _ref4$dirtyFields;

    values = isFunction(values) ? values(stateRef.current.values) : values;
    setStateRef("values", values);
    setAllNodesOrStateValue(values);
    if (touchedFields.length) setStateRef("touched", setTrueValues(stateRef.current.touched, isFunction(touchedFields) ? touchedFields(getFieldNames()) : touchedFields));
    if (dirtyFields.length) setStateRef("dirtyFields", setTrueValues(stateRef.current.dirtyFields, isFunction(dirtyFields) ? dirtyFields(getFieldNames()) : dirtyFields));
    if (shouldValidate) validateFormWithLowPriority();
  }, [getFieldNames, setAllNodesOrStateValue, setStateRef, stateRef, validateFormWithLowPriority, validateOnChange]);
  var setFieldValue = useCallback(function (name, value, _temp3) {
    var _ref5 = _temp3 === void 0 ? {} : _temp3,
        _ref5$shouldValidate = _ref5.shouldValidate,
        shouldValidate = _ref5$shouldValidate === void 0 ? validateOnChange : _ref5$shouldValidate,
        _ref5$shouldTouched = _ref5.shouldTouched,
        shouldTouched = _ref5$shouldTouched === void 0 ? true : _ref5$shouldTouched,
        _ref5$shouldDirty = _ref5.shouldDirty,
        shouldDirty = _ref5$shouldDirty === void 0 ? true : _ref5$shouldDirty;

    value = isFunction(value) ? value(get(stateRef.current.values, name)) : value;

    if (!isUndefined(value)) {
      setStateRef("values." + name, value);
    } else {
      handleUnset("values", "values." + name, stateRef.current.values, name);
    }

    setNodeValue(name, value);
    if (shouldTouched) setFieldTouched(name, false);
    if (shouldDirty) setFieldDirty(name);
    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [handleUnset, setFieldDirty, setFieldTouched, setNodeValue, setStateRef, stateRef, validateFieldWithLowPriority, validateOnChange]);
  var getOptions = useCallback(function () {
    return {
      formState: stateRef.current,
      setErrors: setErrors,
      setFieldError: setFieldError,
      setValues: setValues,
      setFieldValue: setFieldValue,
      validateForm: validateForm,
      validateField: validateField,
      reset: reset,
      submit: submit
    };
  }, [// @ts-expect-error
  reset, setErrors, setFieldError, setFieldValue, setValues, stateRef, // @ts-expect-error
  submit, validateField, validateForm]);
  var reset = useCallback(function (values, exclude, e) {
    e == null ? void 0 : e.preventDefault();
    e == null ? void 0 : e.stopPropagation();

    var state = _extends({}, stateRef.current);

    var skip = arrayToMap(exclude || []);
    Object.keys(state).forEach(function (key) {
      if (skip[key]) return;

      if (key === "values") {
        values = (isFunction(values) ? values(stateRef.current.values) : values) || initialStateRef.current.values;
        state[key] = values;
        setAllNodesOrStateValue(values);
      } else {
        // @ts-expect-error
        state[key] = initialStateRef.current[key];
      }
    });
    setStateRef("", state);
    onResetRef.current(state.values, getOptions(), e);
  }, [getOptions, onResetRef, setAllNodesOrStateValue, setStateRef, stateRef]);
  var submit = useCallback(async function (e) {
    e == null ? void 0 : e.preventDefault();
    e == null ? void 0 : e.stopPropagation();
    var _stateRef$current = stateRef.current,
        touched = _stateRef$current.touched,
        values = _stateRef$current.values;
    setStateRef("touched", setTrueValues(touched, getFieldNames()));
    setStateRef("isSubmitting", true);

    try {
      var errors = await validateForm();

      if (!isEmptyObject(errors)) {
        onErrorRef.current(errors, getOptions(), e);
        return {
          errors: errors
        };
      }

      await onSubmitRef.current(values, getOptions(), e);
      setStateRef("isSubmitted", true);
      return {
        values: values
      };
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > submit: ", exception);
      throw exception;
    } finally {
      setStateRef("isSubmitting", false);
    }
  }, [getFieldNames, getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]);
  var handleChangeEvent = useCallback(function (name, value) {
    setStateRef("values." + name, value);
    setFieldDirty(name);
    if (validateOnChange) validateFieldWithLowPriority(name);
  }, [setFieldDirty, setStateRef, validateFieldWithLowPriority, validateOnChange]);
  var controller = useCallback(function (name, _temp4) {
    var _ref7;

    var _ref6 = _temp4 === void 0 ? {} : _temp4,
        validate = _ref6.validate,
        value = _ref6.value,
        defaultValue = _ref6.defaultValue,
        parse = _ref6.parse,
        format = _ref6.format,
        _onChange = _ref6.onChange,
        _onBlur = _ref6.onBlur;

    if (!name) {
      warn('💡 react-cool-form > controller: Missing the "name" parameter.');
      return undefined;
    }

    controllersRef.current[name] = true;
    if (validate) fieldValidatorsRef.current[name] = validate;
    var val = get(defaultValuesRef.current, name);
    defaultValue = !isUndefined(val) ? val : defaultValue;
    if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);
    value = !isUndefined(value) ? value : getState("values." + name);
    value = (_ref7 = format ? format(value) : value) != null ? _ref7 : "";
    return {
      name: name,
      value: value,
      onChange: function onChange(e) {
        var value = e.nativeEvent instanceof Event && isFieldElement(e.target) ? getNodeValue(name) : e;
        handleChangeEvent(name, parse ? parse(value) : value);
        if (_onChange) _onChange(e, value);
        changedFieldRef.current = name;
      },
      onBlur: function onBlur(e) {
        setFieldTouchedMaybeValidate(name);
        if (_onBlur) _onBlur(e);
        changedFieldRef.current = undefined;
      }
    };
  }, [getNodeValue, getState, handleChangeEvent, setDefaultValue, setFieldTouchedMaybeValidate]);
  useIsoLayoutEffect(function () {
    if (!formRef.current) return;
    fieldsRef.current = getFields(formRef.current);
    setAllNodesOrStateValue(initialStateRef.current.values, true);
    isInitRef.current = false;
  }, [getFields, setAllNodesOrStateValue]);
  useEffect(function () {
    if (!formRef.current) return function () {
      return null;
    };

    var handleChange = function handleChange(_ref8) {
      var target = _ref8.target;
      var _ref9 = target,
          name = _ref9.name;

      if (!name) {
        warn('💡 react-cool-form > field: Missing the "name" attribute.');
        return;
      }

      if (fieldsRef.current[name] && !controllersRef.current[name]) {
        var _fieldArgsRef$current3;

        var parse = (_fieldArgsRef$current3 = fieldArgsRef.current[name]) == null ? void 0 : _fieldArgsRef$current3.parse;
        var value = getNodeValue(name);
        handleChangeEvent(name, parse ? parse(value) : value);
        changedFieldRef.current = name;
      }
    };

    var handleBlur = function handleBlur(_ref10) {
      var target = _ref10.target;
      if (!isFieldElement(target)) return;
      var _ref11 = target,
          name = _ref11.name;

      if (fieldsRef.current[name] && !controllersRef.current[name]) {
        setFieldTouchedMaybeValidate(name);
        changedFieldRef.current = undefined;
      }
    };

    var handleSubmit = function handleSubmit(e) {
      return submit(e);
    };

    var handleReset = function handleReset(e) {
      return reset(null, null, e);
    };

    var form = formRef.current;
    form.addEventListener("input", handleChange);
    form.addEventListener("focusout", handleBlur);
    form.addEventListener("submit", handleSubmit);
    form.addEventListener("reset", handleReset);
    var observer = new MutationObserver(function (_ref12) {
      var type = _ref12[0].type;
      if (type !== "childList") return;
      var fields = getFields(form);
      var values = stateRef.current.values;
      if (removeUnmountedField) Object.keys(fieldsRef.current).forEach(function (name) {
        if (fields[name]) return;
        handleUnset("values", "values." + name, stateRef.current.values, name);
        handleUnset("touched", "touched." + name, stateRef.current.touched, name);
        handleUnset("dirtyFields", "dirtyFields." + name, stateRef.current.dirtyFields, name);
        handleUnset("errors", "errors." + name, stateRef.current.errors, name);
        initialStateRef.current.values = unset(initialStateRef.current.values, name, true);
        delete fieldArgsRef.current[name];
        delete fieldValidatorsRef.current[name];
        delete controllersRef.current[name];
      });
      var isAdd = false;
      Object.keys(fields).forEach(function (name) {
        if (fieldsRef.current[name] || controllersRef.current[name]) return;
        var defaultValue = get(defaultValuesRef.current, name);
        if (!isUndefined(defaultValue)) values = set(values, name, defaultValue, true);
        isAdd = true;
      });
      fieldsRef.current = fields;
      if (isAdd) setAllNodesOrStateValue(values, true);
    });
    observer.observe(form, {
      childList: true,
      subtree: true
    });
    return function () {
      form.removeEventListener("input", handleChange);
      form.removeEventListener("focusout", handleBlur);
      form.removeEventListener("submit", handleSubmit);
      form.removeEventListener("reset", handleReset);
      observer.disconnect();
    };
  }, [getFields, getNodeValue, handleChangeEvent, handleUnset, removeUnmountedField, reset, setAllNodesOrStateValue, setFieldTouchedMaybeValidate, stateRef, submit]);
  return {
    form: formRef,
    field: fieldRef,
    getState: getState,
    setErrors: setErrors,
    setFieldError: setFieldError,
    setValues: setValues,
    setFieldValue: setFieldValue,
    validateForm: validateForm,
    validateField: validateField,
    reset: reset,
    submit: submit,
    controller: controller
  };
});

export { get, set, unset, useForm };
//# sourceMappingURL=index.esm.js.map
