{"version":3,"file":"index.cjs.production.min.js","sources":["../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isObject.ts","../src/utils/isFileList.ts","../src/utils/cloneObject.ts","../src/utils/deepMerge.ts","../src/utils/isPlainObject.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/get.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isFunction.ts","../src/utils/isMultipleSelect.ts","../src/utils/isRadioInput.ts","../src/utils/runWithLowPriority.ts","../src/utils/set.ts","../src/utils/setTrueValues.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/utils/getIsDirty.ts","../src/hooks/useIsoLayoutEffect.ts","../src/useForm.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts"],"sourcesContent":["import { MutableRefObject, useRef, useEffect } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n\n  useEffect(() => {\n    ref.current = val;\n  });\n\n  return ref;\n};\n","import { Map } from \"../types\";\n\nexport default (array: any[]): Map =>\n  array.reduce((obj, key) => {\n    obj[key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","import isObject from \"./isObject\";\nimport isFileList from \"./isFileList\";\n\nconst cloneObject = (object: unknown): any => {\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  if (isObject(object))\n    return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n      obj[key] = cloneObject((object as Record<string, any>)[key]);\n      return obj;\n    }, {});\n\n  throw new Error(\"Unable to clone object.\");\n};\n\nexport default cloneObject;\n","import isObject from \"./isObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isObject(prevValue) && isObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && isObject(value);\n","export default (value: unknown): value is undefined => value === undefined;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error) || error instanceof Date)\n    return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: Record<string, any>, key) => {\n    const nextErrors = filterErrors(\n      (error as Record<string, any>)[key],\n      (touched as Record<string, any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = path\n    .split(/[,[\\].]+?/)\n    .filter(Boolean)\n    .reduce((obj, key) => (obj || {})[key], object);\n\n  return isUndefined(value) ? defaultValue : value;\n};\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is Record<string, never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((callback) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          callback({\n            didTimeout: false,\n            timeRemaining: () => Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n","import cloneObject from \"./cloneObject\";\nimport isObject from \"./isObject\";\nimport isPlainObject from \"./isPlainObject\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable = false\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const segs = String(path)\n    .split(/[.[\\]]+/)\n    .filter(Boolean);\n  const newObject = immutable ? cloneObject(object) : object;\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    if (isObject(obj[key])) return obj[key];\n    const next = Number(segs[idx + 1]);\n    obj[key] = Number.isInteger(next) && next >= 0 ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","import { Map } from \"../types\";\nimport set from \"./set\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, names: string[]): Map =>\n  names.reduce((obj, name) => {\n    obj = set(obj, name, true, true);\n    return obj;\n  }, object);\n","import cloneObject from \"./cloneObject\";\nimport get from \"./get\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, immutable = false): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  let newObject = refObject;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  if (!isUndefined(get(newObject, path))) {\n    const segs = path.split(\".\");\n    let last = segs.pop() as string;\n\n    while (segs.length && segs[segs.length - 1].slice(-1) === \"\\\\\")\n      last = `${(segs.pop() as string).slice(0, -1)}.${last}`;\n\n    while (segs.length) newObject = newObject[(path = segs.shift() as string)];\n\n    delete newObject[last];\n  }\n\n  return refObject;\n};\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  Debug,\n  FormState,\n  FormStateReturn,\n  Map,\n  SetStateRef,\n  SetUsedStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: Debug<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const usedStateRef = useRef<Map>({});\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldUpdate = true } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n\n        return;\n      }\n\n      if (key === \"values\" || !dequal(get(stateRef.current, path), value)) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirtyFields,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n        } = state;\n        let { submitCount: prevSubmitCount } = state;\n        const isDirty =\n          key === \"dirtyFields\" ? getIsDirty(dirtyFields) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (prevSubmitCount += 1)\n            : prevSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n\n        path = fieldPath || path;\n\n        if (\n          shouldUpdate &&\n          (Object.keys(usedStateRef.current).some(\n            (key) => path.startsWith(key) || key.startsWith(path)\n          ) ||\n            (usedStateRef.current.isDirty && isDirty !== prevIsDirty) ||\n            (usedStateRef.current.isValid && isValid !== prevIsValid))\n        ) {\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n      }\n    },\n    [onChangeRef]\n  );\n\n  const setUsedStateRef = useCallback<SetUsedStateRef>((path) => {\n    usedStateRef.current[path] = true;\n  }, []);\n\n  return { stateRef, setStateRef, setUsedStateRef };\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst getIsDirty = (object: object): boolean => {\n  const search = (object: object, found: any[] = []) => {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const obj of Object.values(object)) {\n      if (obj === true) {\n        found.push(obj);\n        return found;\n      }\n\n      if (isPlainObject(obj)) search(obj, found);\n    }\n\n    return found;\n  };\n\n  return !!search(object).length;\n};\n\nexport default getIsDirty;\n","import { useEffect, useLayoutEffect } from \"react\";\n\nconst useIsoLayoutEffect =\n  typeof window === \"undefined\" ? useEffect : useLayoutEffect;\n\nexport default useIsoLayoutEffect;\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport {\n  Config,\n  Controller,\n  Errors,\n  FieldArgs,\n  FieldElement,\n  FieldRef,\n  Fields,\n  FieldValidator,\n  FormState,\n  FormValues,\n  GetState,\n  Map,\n  Reset,\n  Return,\n  SetErrors,\n  SetFieldError,\n  SetFieldValue,\n  SetValues,\n  Submit,\n  ValidateField,\n  ValidateForm,\n} from \"./types\";\nimport { useIsoLayoutEffect, useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  deepMerge,\n  filterErrors,\n  get,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isMultipleSelect,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isUndefined,\n  runWithLowPriority,\n  set,\n  setTrueValues,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  removeUnmountedField = true,\n  ignoreFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  debug,\n}: Config<V>): Return<V> => {\n  const isInitRef = useRef(true);\n  const formRef = useRef<HTMLFormElement>(null);\n  const fieldsRef = useRef<Fields>({});\n  const fieldArgsRef = useRef<FieldArgs>({});\n  const controllersRef = useRef<Map>({});\n  const ignoreFieldsRef = useRef<Map>(arrayToMap(ignoreFields));\n  const changedFieldRef = useRef<string>();\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<Record<string, FieldValidator<V>>>({});\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const defaultValuesRef = useRef(defaultValues);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValuesRef.current,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirtyFields: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, setUsedStateRef } = useState<V>(\n    initialStateRef.current,\n    debug\n  );\n\n  const getFields = useCallback(\n    (form: HTMLFormElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const { type, name, dataset } = field;\n\n          if (/image|submit|reset/.test(type)) return false;\n          if (!name) {\n            warn('💡 react-cool-form > field: Missing the \"name\" attribute.');\n            return false;\n          }\n\n          return (\n            controllersRef.current[name] ||\n            !(dataset.rcfIgnore || ignoreFieldsRef.current[name])\n          );\n        })\n        .reduce((acc: Record<string, any>, cur) => {\n          const field = cur as FieldElement;\n          const { name } = field;\n\n          acc[name] = { ...acc[name], field: cur };\n\n          if (isCheckboxInput(field) || isRadioInput(field))\n            acc[name].options = acc[name].options\n              ? [...acc[name].options, cur]\n              : [cur];\n\n          return acc;\n        }, {}),\n    []\n  );\n\n  const getFieldNames = useCallback(\n    () => Object.keys({ ...fieldsRef.current, ...controllersRef.current }),\n    []\n  );\n\n  const handleUnset = useCallback(\n    (path: string, fieldPath: string, target: any, name: string) => {\n      setStateRef(path, unset(target, name, true), { fieldPath });\n    },\n    [setStateRef]\n  );\n\n  const fieldRef = useCallback<FieldRef<V>>(\n    (validateOrOptions) => (field) => {\n      if (\n        !field?.name ||\n        controllersRef.current[field.name] ||\n        ignoreFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(validateOrOptions)) {\n        fieldValidatorsRef.current[field.name] = validateOrOptions;\n        return;\n      }\n\n      const { validate, ...parsers } = validateOrOptions;\n\n      if (validate) fieldValidatorsRef.current[field.name] = validate;\n      fieldArgsRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  const getNodeValue = useCallback(\n    (name: string) => {\n      const { field, options } = fieldsRef.current[name];\n      let value = field.value as any;\n\n      if (isInputElement(field)) {\n        if (fieldArgsRef.current[name]?.valueAsNumber) {\n          value = field.valueAsNumber;\n          return value;\n        }\n        if (fieldArgsRef.current[name]?.valueAsDate) {\n          value = field.valueAsDate;\n          return value;\n        }\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        value = field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        if (options) {\n          const checkboxs = options as HTMLInputElement[];\n\n          if (options.length > 1) {\n            value = checkboxs\n              .filter((checkbox) => checkbox.checked)\n              .map((checkbox) => checkbox.value);\n          } else {\n            value = checkboxs[0].checked;\n          }\n        } else {\n          let checkValues = get(stateRef.current.values, field.name);\n\n          if (Array.isArray(checkValues)) {\n            checkValues = new Set(checkValues);\n\n            if (field.checked) {\n              checkValues.add(value);\n            } else {\n              checkValues.delete(value);\n            }\n\n            value = Array.from(checkValues);\n          } else {\n            value = field.checked;\n          }\n        }\n      }\n\n      if (isRadioInput(field) && options)\n        value =\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\";\n\n      if (isMultipleSelect(field) && !options)\n        value = Array.from(field.options)\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) value = field.files;\n\n      return value;\n    },\n    [stateRef]\n  );\n\n  const setNodeValue = useCallback((name: string, value: any) => {\n    if (!fieldsRef.current[name] || controllersRef.current[name]) return;\n\n    const { field, options } = fieldsRef.current[name];\n\n    if (isCheckboxInput(field)) {\n      const checkboxs = options as HTMLInputElement[];\n\n      if (checkboxs.length > 1) {\n        checkboxs.forEach((checkbox) => {\n          checkbox.checked = Array.isArray(value)\n            ? value.includes(checkbox.value)\n            : !!value;\n        });\n      } else {\n        checkboxs[0].checked = !!value;\n      }\n    } else if (isRadioInput(field)) {\n      (options as HTMLInputElement[]).forEach((radio) => {\n        radio.checked = radio.value === value;\n      });\n    } else if (isMultipleSelect(field) && Array.isArray(value)) {\n      Array.from(field.options).forEach((option) => {\n        option.selected = !!value.includes(option.value);\n      });\n    } else if (isFileInput(field)) {\n      if (isFileList(value)) field.files = value;\n      if (!value) field.value = \"\";\n    } else {\n      field.value = value ?? \"\";\n    }\n  }, []);\n\n  const setDefaultValue = useCallback(\n    (name: string, value: any) => {\n      if (!isUndefined(get(initialStateRef.current.values, name))) return;\n\n      initialStateRef.current.values = set(\n        initialStateRef.current.values,\n        name,\n        value,\n        true\n      );\n\n      setStateRef(`values.${name}`, get(initialStateRef.current.values, name), {\n        shouldUpdate: !isInitRef.current,\n      });\n    },\n    [setStateRef]\n  );\n\n  const setAllNodesOrStateValue = useCallback(\n    (values: V, checkDefaultValues = false) =>\n      Object.values(fieldsRef.current).forEach(({ field: { name } }) => {\n        if (controllersRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (checkDefaultValues) {\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          setDefaultValue(\n            name,\n            !isUndefined(defaultValue) ? defaultValue : getNodeValue(name)\n          );\n        }\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const getState = useCallback<GetState>(\n    (path, { target, watch = true, filterUntouchedError = true } = {}) => {\n      const getPath = (path: string) => {\n        if (path === \"values\" && !target && watch)\n          warn(\n            '💡 react-cool-form > getState: Get the \"values\" alone may cause unnecessary re-renders. If you know what you\\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/form-state'\n          );\n\n        return target ? `${target}.${path}` : path;\n      };\n      const errorsEnhancer = (path: string, state: any) => {\n        if (\n          !watch ||\n          !filterUntouchedError ||\n          !path.startsWith(\"errors\") ||\n          !state ||\n          isEmptyObject(state)\n        )\n          return state;\n\n        path = path.replace(\"errors\", \"touched\");\n        setUsedStateRef(path);\n\n        return filterErrors(state, get(stateRef.current, path));\n      };\n      let state;\n\n      if (Array.isArray(path)) {\n        state = path.map((path) => {\n          path = getPath(path);\n          if (watch) setUsedStateRef(path);\n          return errorsEnhancer(path, get(stateRef.current, path));\n        });\n      } else if (isPlainObject(path)) {\n        const paths = path as Record<string, string>;\n        state = Object.keys(paths).reduce((state: Record<string, any>, key) => {\n          path = getPath(paths[key]);\n          if (watch) setUsedStateRef(path);\n          state[key] = errorsEnhancer(path, get(stateRef.current, path));\n          return state;\n        }, {});\n      } else {\n        path = getPath(path);\n        if (watch) setUsedStateRef(path);\n        state = errorsEnhancer(path, get(stateRef.current, path));\n      }\n\n      return state;\n    },\n    [setUsedStateRef, stateRef]\n  );\n\n  const setErrors = useCallback<SetErrors<V>>(\n    (errors) => {\n      setStateRef(\n        \"errors\",\n        (isFunction(errors) ? errors(stateRef.current.errors) : errors) || {}\n      );\n    },\n    [setStateRef, stateRef]\n  );\n\n  const setFieldError = useCallback<SetFieldError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => fieldsRef.current[name]?.field.validationMessage,\n    []\n  );\n\n  const runAllBuiltInValidation = useCallback(\n    () =>\n      Object.keys(fieldsRef.current).reduce((errors, name) => {\n        const error = runBuiltInValidation(name);\n        errors = { ...errors, ...(error ? set({}, name, error) : {}) };\n        return errors;\n      }, {}),\n    [runBuiltInValidation]\n  );\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      if (!fieldValidatorsRef.current[name]) return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          get(stateRef.current.values, name),\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`💡 react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<Errors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set({}, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`💡 react-cool-form > config.validate: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback<ValidateField>(\n    async (name) => {\n      setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setFieldError(name, error);\n        setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setFieldError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<ValidateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback<ValidateForm<V>>(() => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setErrors(errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setErrors,\n    setStateRef,\n  ]);\n\n  const validateFormWithLowPriority = useCallback<ValidateForm<V>>(\n    () => runWithLowPriority(validateForm),\n    [validateForm]\n  );\n\n  const setFieldDirty = useCallback(\n    (name: string) => {\n      if (\n        get(stateRef.current.values, name) !==\n        get(initialStateRef.current.values, name)\n      ) {\n        setStateRef(`dirtyFields.${name}`, true);\n      } else {\n        handleUnset(\n          \"dirtyFields\",\n          `dirtyFields.${name}`,\n          stateRef.current.dirtyFields,\n          name\n        );\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const setFieldTouched = useCallback(\n    (name: string, shouldValidate = validateOnBlur) => {\n      setStateRef(`touched.${name}`, true);\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [setStateRef, validateFieldWithLowPriority, validateOnBlur]\n  );\n\n  const setFieldTouchedMaybeValidate = useCallback(\n    (name) =>\n      setFieldTouched(\n        name,\n        validateOnChange ? name !== changedFieldRef.current : undefined\n      ),\n    [setFieldTouched, validateOnChange]\n  );\n\n  const setValues = useCallback<SetValues<V>>(\n    (\n      values,\n      {\n        shouldValidate = validateOnChange,\n        touchedFields = [],\n        dirtyFields = [],\n      } = {}\n    ) => {\n      values = isFunction(values) ? values(stateRef.current.values) : values;\n\n      setStateRef(\"values\", values);\n      setAllNodesOrStateValue(values);\n\n      if (touchedFields.length)\n        setStateRef(\n          \"touched\",\n          setTrueValues(\n            stateRef.current.touched,\n            isFunction(touchedFields)\n              ? touchedFields(getFieldNames())\n              : touchedFields\n          )\n        );\n      if (dirtyFields.length)\n        setStateRef(\n          \"dirtyFields\",\n          setTrueValues(\n            stateRef.current.dirtyFields,\n            isFunction(dirtyFields) ? dirtyFields(getFieldNames()) : dirtyFields\n          )\n        );\n      if (shouldValidate) validateFormWithLowPriority();\n    },\n    [\n      getFieldNames,\n      setAllNodesOrStateValue,\n      setStateRef,\n      stateRef,\n      validateFormWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const setFieldValue = useCallback<SetFieldValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(\"values\", `values.${name}`, stateRef.current.values, name);\n      }\n      setNodeValue(name, value);\n\n      if (shouldTouched) setFieldTouched(name, false);\n      if (shouldDirty) setFieldDirty(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setFieldDirty,\n      setFieldTouched,\n      setNodeValue,\n      setStateRef,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      formState: stateRef.current,\n      setErrors,\n      setFieldError,\n      setValues,\n      setFieldValue,\n      validateForm,\n      validateField,\n      reset,\n      submit,\n    }),\n    [\n      // @ts-expect-error\n      reset,\n      setErrors,\n      setFieldError,\n      setFieldValue,\n      setValues,\n      stateRef,\n      // @ts-expect-error\n      submit,\n      validateField,\n      validateForm,\n    ]\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          values =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = values;\n          setAllNodesOrStateValue(values);\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n    },\n    [getOptions, onResetRef, setAllNodesOrStateValue, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const { touched, values } = stateRef.current;\n\n      setStateRef(\"touched\", setTrueValues(touched, getFieldNames()));\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const errors = await validateForm();\n\n        if (!isEmptyObject(errors)) {\n          onErrorRef.current(errors, getOptions(), e);\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values };\n      } catch (exception) {\n        warn(`💡 react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [\n      getFieldNames,\n      getOptions,\n      onErrorRef,\n      onSubmitRef,\n      setStateRef,\n      stateRef,\n      validateForm,\n    ]\n  );\n\n  const handleChangeEvent = useCallback(\n    (name: string, value: any) => {\n      setStateRef(`values.${name}`, value);\n      setFieldDirty(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [setFieldDirty, setStateRef, validateFieldWithLowPriority, validateOnChange]\n  );\n\n  const controller = useCallback<Controller<V>>(\n    (\n      name,\n      { validate, value, defaultValue, parse, format, onChange, onBlur } = {}\n    ) => {\n      if (!name) {\n        warn('💡 react-cool-form > controller: Missing the \"name\" parameter.');\n        return undefined;\n      }\n\n      controllersRef.current[name] = true;\n      if (validate) fieldValidatorsRef.current[name] = validate;\n\n      const val = get(defaultValuesRef.current, name);\n      defaultValue = !isUndefined(val) ? val : defaultValue;\n      if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);\n\n      value = !isUndefined(value) ? value : getState(`values.${name}`);\n      value = (format ? format(value) : value) ?? \"\";\n\n      return {\n        name,\n        value,\n        onChange: (e) => {\n          const value =\n            e.nativeEvent instanceof Event && isFieldElement(e.target)\n              ? getNodeValue(name)\n              : e;\n\n          handleChangeEvent(name, parse ? parse(value) : value);\n          if (onChange) onChange(e, value);\n          changedFieldRef.current = name;\n        },\n        onBlur: (e) => {\n          setFieldTouchedMaybeValidate(name);\n          if (onBlur) onBlur(e);\n          changedFieldRef.current = undefined;\n        },\n      };\n    },\n    [\n      getNodeValue,\n      getState,\n      handleChangeEvent,\n      setDefaultValue,\n      setFieldTouchedMaybeValidate,\n    ]\n  );\n\n  useIsoLayoutEffect(() => {\n    if (!formRef.current) return;\n\n    fieldsRef.current = getFields(formRef.current);\n    setAllNodesOrStateValue(initialStateRef.current.values, true);\n    isInitRef.current = false;\n  }, [getFields, setAllNodesOrStateValue]);\n\n  useEffect(() => {\n    if (!formRef.current) return () => null;\n\n    const handleChange = ({ target }: Event) => {\n      const { name } = target as FieldElement;\n\n      if (!name) {\n        warn('💡 react-cool-form > field: Missing the \"name\" attribute.');\n        return;\n      }\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        const parse = fieldArgsRef.current[name]?.parse;\n        const value = getNodeValue(name);\n\n        handleChangeEvent(name, parse ? parse(value) : value);\n        changedFieldRef.current = name;\n      }\n    };\n\n    const handleBlur = ({ target }: Event) => {\n      if (!isFieldElement(target as HTMLElement)) return;\n\n      const { name } = target as FieldElement;\n\n      if (fieldsRef.current[name] && !controllersRef.current[name]) {\n        setFieldTouchedMaybeValidate(name);\n        changedFieldRef.current = undefined;\n      }\n    };\n\n    const handleSubmit = (e: Event) => submit(e as any);\n\n    const handleReset = (e: Event) => reset(null, null, e as any);\n\n    const form = formRef.current;\n    form.addEventListener(\"input\", handleChange);\n    form.addEventListener(\"focusout\", handleBlur);\n    form.addEventListener(\"submit\", handleSubmit);\n    form.addEventListener(\"reset\", handleReset);\n\n    const observer = new MutationObserver(([{ type }]) => {\n      if (type !== \"childList\") return;\n\n      const fields = getFields(form);\n      let { values } = stateRef.current;\n\n      if (removeUnmountedField)\n        Object.keys(fieldsRef.current).forEach((name) => {\n          if (fields[name]) return;\n\n          handleUnset(\n            \"values\",\n            `values.${name}`,\n            stateRef.current.values,\n            name\n          );\n          handleUnset(\n            \"touched\",\n            `touched.${name}`,\n            stateRef.current.touched,\n            name\n          );\n          handleUnset(\n            \"dirtyFields\",\n            `dirtyFields.${name}`,\n            stateRef.current.dirtyFields,\n            name\n          );\n          handleUnset(\n            \"errors\",\n            `errors.${name}`,\n            stateRef.current.errors,\n            name\n          );\n\n          initialStateRef.current.values = unset(\n            initialStateRef.current.values,\n            name,\n            true\n          );\n\n          delete fieldArgsRef.current[name];\n          delete fieldValidatorsRef.current[name];\n          delete controllersRef.current[name];\n        });\n\n      let isAdd = false;\n\n      Object.keys(fields).forEach((name) => {\n        if (fieldsRef.current[name] || controllersRef.current[name]) return;\n\n        const defaultValue = get(defaultValuesRef.current, name);\n\n        if (!isUndefined(defaultValue))\n          values = set(values, name, defaultValue, true);\n\n        isAdd = true;\n      });\n\n      fieldsRef.current = fields;\n      if (isAdd) setAllNodesOrStateValue(values, true);\n    });\n    observer.observe(form, { childList: true, subtree: true });\n\n    return () => {\n      form.removeEventListener(\"input\", handleChange);\n      form.removeEventListener(\"focusout\", handleBlur);\n      form.removeEventListener(\"submit\", handleSubmit);\n      form.removeEventListener(\"reset\", handleReset);\n      observer.disconnect();\n    };\n  }, [\n    getFields,\n    getNodeValue,\n    handleChangeEvent,\n    handleUnset,\n    removeUnmountedField,\n    reset,\n    setAllNodesOrStateValue,\n    setFieldTouchedMaybeValidate,\n    stateRef,\n    submit,\n  ]);\n\n  return {\n    form: formRef,\n    field: fieldRef,\n    getState,\n    setErrors,\n    setFieldError,\n    setValues,\n    setFieldValue,\n    validateForm,\n    validateField,\n    reset,\n    submit,\n    controller,\n  };\n};\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n"],"names":["val","ref","useRef","useEffect","current","array","reduce","obj","key","value","FileList","cloneObject","object","isObject","isFileList","Date","getTime","Array","isArray","map","Object","keys","Error","deepMerge","objects","prev","forEach","prevValue","currValue","undefined","filterErrors","error","touched","isPlainObject","nextErrors","isUndefined","path","defaultValue","split","filter","Boolean","field","type","length","element","test","tagName","callback","window","requestIdleCallback","start","now","setTimeout","didTimeout","timeRemaining","Math","max","timeout","immutable","TypeError","segs","String","newObject","slice","idx","next","Number","isInteger","names","name","set","refObject","hasOwnProperty","get","last","pop","shift","initialState","onChange","forceUpdate","useReducer","c","stateRef","usedStateRef","onChangeRef","useLatest","setStateRef","useCallback","fieldPath","shouldUpdate","dequal","state","errors","dirtyFields","prevIsDirty","isDirty","prevIsValid","isValid","prevSubmitCount","submitCount","search","found","values","push","isEmptyObject","some","startsWith","setUsedStateRef","useIsoLayoutEffect","useLayoutEffect","defaultValues","validate","validateOnChange","validateOnBlur","removeUnmountedField","ignoreFields","onReset","onSubmit","onError","debug","isInitRef","formRef","fieldsRef","fieldArgsRef","controllersRef","ignoreFieldsRef","arrayToMap","changedFieldRef","formValidatorRef","fieldValidatorsRef","onResetRef","onSubmitRef","onErrorRef","defaultValuesRef","initialStateRef","isValidating","isSubmitting","isSubmitted","useState","getFields","form","from","querySelectorAll","dataset","rcfIgnore","acc","cur","isCheckboxInput","isRadioInput","options","getFieldNames","handleUnset","target","unset","fieldRef","validateOrOptions","isFunction","parsers","getNodeValue","_fieldArgsRef$current","valueAsNumber","_fieldArgsRef$current2","valueAsDate","isNumberInput","isRangeInput","checkboxs","checkbox","checked","checkValues","Set","add","find","radio","isMultipleSelect","option","selected","isFileInput","files","setNodeValue","includes","setDefaultValue","setAllNodesOrStateValue","checkDefaultValues","getState","watch","filterUntouchedError","getPath","errorsEnhancer","replace","paths","setErrors","setFieldError","runBuiltInValidation","_fieldsRef$current$na3","validationMessage","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","all","then","runFormValidation","validateField","validateFieldWithLowPriority","runWithLowPriority","validateForm","errs","validateFormWithLowPriority","setFieldDirty","setFieldTouched","shouldValidate","setFieldTouchedMaybeValidate","setValues","touchedFields","setTrueValues","setFieldValue","shouldTouched","shouldDirty","getOptions","formState","reset","submit","exclude","e","preventDefault","stopPropagation","skip","handleChangeEvent","controller","parse","format","onBlur","nativeEvent","Event","isFieldElement","handleChange","_fieldArgsRef$current3","handleBlur","handleSubmit","handleReset","addEventListener","observer","MutationObserver","fields","isAdd","observe","childList","subtree","removeEventListener","disconnect"],"mappings":"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"}